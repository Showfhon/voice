{"meta":{"version":"0.3.0","format":20,"date":1641398588805},"custom":{"general":{"name":"General","files":{"welcome":{"name":"Welcome","type":"md","content":"<div align=\"center\">\n\t<br />\n\t<p>\n\t\t<a href=\"https://discord.js.org\"><img src=\"https://discord.js.org/static/logo.svg\" width=\"546\" alt=\"discord.js\" /></a>\n\t</p>\n\t<br />\n\t\t<p>\n\t\t<a href=\"https://discord.gg/djs\"><img src=\"https://img.shields.io/discord/222078108977594368?color=5865F2&logo=discord&logoColor=white\" alt=\"Discord server\" /></a>\n\t\t<a href=\"https://www.npmjs.com/package/@discordjs/voice\"><img src=\"https://img.shields.io/npm/v/@discordjs/voice.svg?maxAge=3600\" alt=\"npm version\" /></a>\n\t\t<a href=\"https://www.npmjs.com/package/@discordjs/voice\"><img src=\"https://img.shields.io/npm/dt/@discordjs/voice.svg?maxAge=3600\" alt=\"npm downloads\" /></a>\n\t\t<a href=\"https://github.com/discordjs/voice/actions\"><img src=\"https://github.com/discordjs/voice/workflows/Tests/badge.svg\" alt=\"Build status\" /></a>\n\t\t<a href=\"https://codecov.io/gh/discordjs/voice\"><img src=\"https://codecov.io/gh/discordjs/voice/branch/main/graph/badge.svg\" alt=\"Code coverage\" /></a>\n\t\t<a href=\"https://www.patreon.com/discordjs\"><img src=\"https://img.shields.io/badge/donate-patreon-F96854.svg\" alt=\"Patreon\" /></a>\n\t</p>\n</div>\n\n## About\n\nAn implementation of the Discord Voice API for Node.js, written in TypeScript.\n\n**Features:**\n\n- Send and receive* audio in Discord voice-based channels\n- A strong focus on reliability and predictable behaviour\n- Horizontal scalability and libraries other than [discord.js](https://discord.js.org/) are supported with custom adapters\n- A robust audio processing system that can handle a wide range of audio sources\n\n\\**Audio receive is not documented by Discord so stable support is not guaranteed*\n\n## Installation\n\n**Node.js 16.0.0 or newer is required.**\n\n```sh-session\nnpm install @discordjs/voice\nyarn add @discordjs/voice\npnpm add @discordjs/voice\n```\n\n## Dependencies\n\nThis library has several optional dependencies to support a variety\nof different platforms. Install one dependency from each of the\ncategories shown below. The dependencies are listed in order of\npreference for performance. If you can't install one of the options,\ntry installing another.\n\n**Encryption Libraries (npm install):**\n\n- `sodium`: ^3.0.2\n- `tweetnacl`: ^1.0.3\n- `libsodium-wrappers`: ^0.7.9\n\n**Opus Libraries (npm install):**\n\n- `@discordjs/opus`: ^0.4.0\n- `opusscript`: ^0.0.7\n\n**FFmpeg:**\n\n- [`FFmpeg`](https://ffmpeg.org/) (installed and added to environment)\n- `ffmpeg-static`: ^4.2.7 (npm install)\n\n## Links\n\n- [Website](https://discord.js.org/) ([source](https://github.com/discordjs/website))\n- [Documentation](https://discord.js.org/#/docs/voice)\n- [Examples](https://github.com/discordjs/voice/tree/main/examples)\n- [discord.js Discord server](https://discord.gg/djs)\n- [GitHub](https://github.com/discordjs/voice)\n- [npm](https://www.npmjs.com/package/@discordjs/voice)\n\n## Contributing\n\nBefore creating an issue, please ensure that it hasn't already been reported/suggested, and double-check the\n[documentation](https://discord.js.org/#/docs/voice).  \nSee [the contribution guide](https://github.com/discordjs/voice/blob/main/.github/CONTRIBUTING.md) if you'd like to submit a PR.\n\n## Help\n\nIf you don't understand something in the documentation, you are experiencing problems, or you just need a gentle\nnudge in the right direction, please don't hesitate to join our official [discord.js Server](https://discord.gg/djs).\n","path":"README.md"}}}},"classes":[{"name":"AudioPlayer","description":"Used to play audio resources (i.e. tracks, streams) to voice connections.","see":[],"extends":["TypedEmitter<AudioPlayerEvents>"],"abstract":false,"deprecated":false,"construct":{"name":"constructor","description":"Creates a new AudioPlayer.","params":[{"name":"options","optional":true,"default":"{}","type":[[["CreateAudioPlayerOptions"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":204,"file":"AudioPlayer.ts","path":"src/audio"}},"props":[{"name":"_state","description":"The state that the AudioPlayer is in.","access":"private","type":[[["AudioPlayerState"]]],"meta":{"line":180,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"behaviors","description":"The behavior that the player should follow when it enters certain situations.","access":"private","readonly":true,"type":[[["{"],["\nmaxMissedFrames",": "],["number",","],["\nnoSubscriber",": "],["NoSubscriberBehavior\n","}"]]],"meta":{"line":191,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"debug","description":"The debug logger function, if debugging is enabled.","access":"private","readonly":true,"type":[[["null"," | ("],["message",": "],["string",") => "],["void"]]],"meta":{"line":199,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"subscribers","description":"A list of VoiceConnections that are registered to this AudioPlayer. The player will attempt to play audio\nto the streams in this list.","access":"private","readonly":true,"default":"[]","type":[[["Array","<"],["PlayerSubscription",">"]]],"meta":{"line":186,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":10,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"playable","description":"A list of subscribed voice connections that can currently receive audio to play.","readonly":true,"type":[[["Array","<"],["VoiceConnection",">"]]],"meta":{"line":218,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"state","description":"The state that the player is in.","readonly":false,"type":[[["AudioPlayerState"]]],"meta":{"line":272,"file":"AudioPlayer.ts","path":"src/audio"}}],"methods":[{"name":"_preparePacket","description":"Instructs the given connections to each prepare this packet to be played at the start of the\nnext cycle.","access":"private","params":[{"name":"packet","description":"The Opus packet to be prepared by each receiver","optional":false,"type":[[["Buffer"]]]},{"name":"receivers","description":"The connections that should play this packet","optional":false,"type":[[["Array","<"],["VoiceConnection",">"]]]},{"name":"state","optional":false,"type":[[["AudioPlayerPlayingState"," | "],["AudioPlayerPausedState"]]]}],"returns":[[["void"]]],"meta":{"line":599,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"_signalStopSpeaking","description":"Signals to all the subscribed connections that they should send a packet to Discord indicating\nthey are no longer speaking. Called once playback of a resource ends.","access":"private","returns":[[["void"]]],"meta":{"line":588,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"_stepDispatch","description":"Called roughly every 20ms by the global audio player timer. Dispatches any audio packets that are buffered\nby the active connections of this audio player.","access":"private","returns":[[["void"]]],"meta":{"line":500,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"_stepPrepare","description":"Called roughly every 20ms by the global audio player timer. Attempts to read an audio packet from the\nunderlying resource of the stream, and then has all the active connections of the audio player prepare it\n(encrypt it, append header data) so that it is ready to play at the start of the next cycle.","access":"private","returns":[[["void"]]],"meta":{"line":516,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"addListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["AudioPlayerEvents","["],["U","]"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":11,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"checkPlayable","description":"Checks whether the underlying resource (if any) is playable (readable)","returns":[[["boolean"]]],"returnsDescription":"`true` if the resource is playable, otherwise `false`","meta":{"line":481,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"emit","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"args","optional":false,"type":[[["Parameters","<"],["AudioPlayerEvents","["],["U","]>"]]]}],"returns":[[["boolean"]]],"meta":{"line":19,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"eventNames","returns":[[["Array","<"],["U",">"]]],"meta":{"line":20,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"getMaxListeners","returns":[[["number"]]],"meta":{"line":24,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listenerCount","params":[{"name":"type","optional":false,"type":[[["'subscribe'"," | "],["AudioPlayerStatus"," | "],["'error'"," | "],["'debug'"," | "],["'stateChange'"," | "],["'unsubscribe'"]]]}],"returns":[[["number"]]],"meta":{"line":21,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["AudioPlayerEvents","["],["U","]>"]]],"meta":{"line":22,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"off","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["AudioPlayerEvents","["],["U","]"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":18,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"on","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["AudioPlayerEvents","["],["U","]"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":17,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"once","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["AudioPlayerEvents","["],["U","]"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":16,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"pause","description":"Pauses playback of the current resource, if any.","params":[{"name":"interpolateSilence","description":"If true, the player will play 5 packets of silence after pausing to prevent audio glitches","optional":true,"default":"true","type":[[["boolean"]]]}],"returns":[[["boolean"]]],"returnsDescription":"`true` if the player was successfully paused, otherwise `false`","meta":{"line":431,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"play","description":"Plays a new resource on the player. If the player is already playing a resource, the existing resource is destroyed\n(it cannot be reused, even in another player) and is replaced with the new resource.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"resource","description":"The resource to play","optional":false,"type":[[["AudioResource","<"],["T",">"]]]}],"returns":[[["void"]]],"meta":{"line":344,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"prependListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["AudioPlayerEvents","["],["U","]"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":12,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"prependOnceListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["AudioPlayerEvents","["],["U","]"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":13,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"rawListeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["AudioPlayerEvents","["],["U","]>"]]],"meta":{"line":23,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"removeAllListeners","params":[{"name":"event","optional":true,"type":[[["'subscribe'"," | "],["AudioPlayerStatus"," | "],["'error'"," | "],["'debug'"," | "],["'stateChange'"," | "],["'unsubscribe'"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":15,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"removeListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["AudioPlayerEvents","["],["U","]"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":14,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"setMaxListeners","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[["AudioPlayer"]]],"meta":{"line":25,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"stop","description":"Stops playback of the current resource and destroys the resource. The player will either transition to the Idle state,\nor remain in its current state until the silence padding frames of the resource have been played.","params":[{"name":"force","description":"If true, will force the player to enter the Idle state even if the resource has silence padding frames","optional":true,"default":"false","type":[[["boolean"]]]}],"returns":[[["boolean"]]],"returnsDescription":"`true` if the player will come to a stop, otherwise `false`","meta":{"line":464,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"subscribe","description":"Subscribes a VoiceConnection to the audio player's play list. If the VoiceConnection is already subscribed,\nthen the existing subscription is used.","see":[],"access":"private","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"connection","description":"The connection to subscribe","optional":false,"type":[[["VoiceConnection"]]]}],"returns":[[["PlayerSubscription"]]],"returnsDescription":"The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription","meta":{"line":236,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"unpause","description":"Unpauses playback of the current resource, if any.","returns":[[["boolean"]]],"returnsDescription":"`true` if the player was successfully unpaused, otherwise `false`","meta":{"line":446,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"unsubscribe","description":"Unsubscribes a subscription - i.e. removes a voice connection from the play list of the audio player.","see":[],"access":"private","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"subscription","description":"The subscription to remove","optional":false,"type":[[["PlayerSubscription"]]]}],"returns":[[["boolean"]]],"returnsDescription":"Whether or not the subscription existed on the player and was removed","meta":{"line":258,"file":"AudioPlayer.ts","path":"src/audio"}}],"meta":{"line":176,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"AudioPlayerError","description":"An error emitted by an AudioPlayer. Contains an attached resource to aid with\ndebugging and identifying where the error came from.","extends":["Error"],"construct":{"name":"constructor","params":[{"name":"error","optional":false,"type":[[["Error"]]]},{"name":"resource","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]}],"returns":[[["AudioPlayerError"]]],"meta":{"line":12,"file":"AudioPlayerError.ts","path":"src/audio"}},"props":[{"name":"message","type":[[["string"]]],"meta":{"line":974,"file":"lib.es5.d.ts","path":"node_modules/typescript/lib"}},{"name":"name","type":[[["string"]]],"meta":{"line":973,"file":"lib.es5.d.ts","path":"node_modules/typescript/lib"}},{"name":"resource","description":"The resource associated with the audio player at the time the error was thrown.","readonly":true,"type":[[["AudioResource","<"],["unknown",">"]]],"meta":{"line":11,"file":"AudioPlayerError.ts","path":"src/audio"}},{"name":"stack","type":[[["string"]]],"meta":{"line":975,"file":"lib.es5.d.ts","path":"node_modules/typescript/lib"}},{"name":"prepareStackTrace","scope":"static","type":[[["("],["err",": "],["Error",", "],["stackTraces",": "],["Array","<"],["CallSite",">) => "],["any"]]],"meta":{"line":11,"file":"globals.d.ts","path":"node_modules/@types/node"}},{"name":"stackTraceLimit","scope":"static","type":[[["number"]]],"meta":{"line":13,"file":"globals.d.ts","path":"node_modules/@types/node"}}],"methods":[{"name":"captureStackTrace","description":"Create .stack property on a target object","scope":"static","params":[{"name":"targetObject","optional":false,"type":[[["object"]]]},{"name":"constructorOpt","optional":true,"type":[[["Function"]]]}],"returns":[[["void"]]]}],"meta":{"line":7,"file":"AudioPlayerError.ts","path":"src/audio"}},{"name":"AudioReceiveStream","description":"A readable stream of Opus packets received from a specific entity\nin a Discord voice connection.","extends":["Readable"],"construct":{"name":"constructor","params":[{"name":"__namedParameters","optional":false,"type":[[["AudioReceiveStreamOptions"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":57,"file":"AudioReceiveStream.ts","path":"src/receive"}},"props":[{"name":"destroyed","description":"Is `true` after `readable.destroy()` has been called.","see":[],"abstract":false,"deprecated":false,"type":[[["boolean"]]],"meta":{"line":115,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"end","description":"The end behavior of the receive stream.","readonly":true,"type":[[["EndBehavior"]]],"meta":{"line":53,"file":"AudioReceiveStream.ts","path":"src/receive"}},{"name":"endTimeout","access":"private","type":[[["Timeout"]]],"meta":{"line":55,"file":"AudioReceiveStream.ts","path":"src/receive"}},{"name":"readable","description":"Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.","see":[],"abstract":false,"deprecated":false,"type":[[["boolean"]]],"meta":{"line":71,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableAborted","description":"Returns whether the stream was destroyed or errored before emitting `'end'`.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["boolean"]]],"meta":{"line":65,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableDidRead","description":"Returns whether `'data'` has been emitted.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["boolean"]]],"meta":{"line":77,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableEncoding","description":"Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["null"," | "],["BufferEncoding"]]],"meta":{"line":82,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableEnded","description":"Becomes `true` when `'end'` event is emitted.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["boolean"]]],"meta":{"line":87,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableFlowing","description":"This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["null"," | "],["boolean"]]],"meta":{"line":93,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableHighWaterMark","description":"Returns the value of `highWaterMark` passed when creating this `Readable`.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["number"]]],"meta":{"line":98,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableLength","description":"This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["number"]]],"meta":{"line":105,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"readableObjectMode","description":"Getter for the property `objectMode` of a given `Readable` stream.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["boolean"]]],"meta":{"line":110,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"captureRejectionSymbol","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["captureRejectionSymbol",")"]]],"meta":{"line":273,"file":"events.d.ts","path":"node_modules/@types/node"}},{"name":"captureRejections","description":"Sets or gets the default captureRejection value for all emitters.","scope":"static","type":[[["boolean"]]],"meta":{"line":278,"file":"events.d.ts","path":"node_modules/@types/node"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":279,"file":"events.d.ts","path":"node_modules/@types/node"}},{"name":"errorMonitor","description":"This symbol shall be used to install a listener for only monitoring `'error'`\nevents. Listeners installed using this symbol are called before the regular\n`'error'` listeners are called.","scope":"static","readonly":true,"type":[[["("],["typeof"," "],["errorMonitor",")"]]],"meta":{"line":272,"file":"events.d.ts","path":"node_modules/@types/node"}}],"methods":[{"name":"[asyncIterator]","returns":[[["AsyncIterableIterator","<"],["any",">"]]],"meta":{"line":479,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"_construct","params":[{"name":"callback","optional":false,"type":[[["("],["error",": "],["null"," | "],["Error",") => "],["void"]]]}],"returns":[[["void"]]],"meta":{"line":117,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"_destroy","params":[{"name":"error","optional":false,"type":[[["null"," | "],["Error"]]]},{"name":"callback","optional":false,"type":[[["("],["error",": "],["null"," | "],["Error",") => "],["void"]]]}],"returns":[[["void"]]],"meta":{"line":399,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"_read","returns":[[["void"]]],"meta":{"line":88,"file":"AudioReceiveStream.ts","path":"src/receive"}},{"name":"addListener","description":"Event emitter\nThe defined events on documents including:\n1. close\n2. data\n3. end\n4. error\n5. pause\n6. readable\n7. resume","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":423,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"destroy","description":"Destroy the stream. Optionally emit an `'error'` event, and emit a `'close'`event (unless `emitClose` is set to `false`). After this call, the readable\nstream will release any internal resources and subsequent calls to `push()`will be ignored.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"error","description":"Error which will be passed as payload in `'error'` event","optional":true,"type":[[["Error"]]]}],"returns":[[["void"]]],"meta":{"line":411,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"emit","params":[{"name":"event","optional":false,"type":[[["'close'"]]]}],"returns":[[["boolean"]]],"meta":{"line":431,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"eventNames","description":"Returns an array listing the events for which the emitter has registered\nlisteners. The values in the array are strings or `Symbol`s.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"returns":[[["Array","<"],["string"," | "],["symbol",">"]]]},{"name":"getMaxListeners","description":"Returns the current max listener value for the `EventEmitter` which is either\nset by `emitter.setMaxListeners(n)` or defaults to {@link defaultMaxListeners}.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"returns":[[["number"]]]},{"name":"isPaused","description":"The `readable.isPaused()` method returns the current operating state of the`Readable`. This is used primarily by the mechanism that underlies the`readable.pipe()` method. In most\ntypical cases, there will be no reason to\nuse this method directly.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"returns":[[["boolean"]]],"meta":{"line":278,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"listenerCount","description":"Returns the number of listeners listening to the event named `eventName`.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[["number"]]]},{"name":"listeners","description":"Returns a copy of the array of listeners for the event named `eventName`.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[["Array","<"],["Function",">"]]]},{"name":"off","description":"Alias for `emitter.removeListener()`.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"listener","optional":false,"type":[[["("],["args",": "],["Array","<"],["any",">) => "],["void"]]]}],"returns":[[["AudioReceiveStream"]]]},{"name":"on","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":439,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"once","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":447,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"pause","description":"The `readable.pause()` method will cause a stream in flowing mode to stop\nemitting `'data'` events, switching out of flowing mode. Any data that\nbecomes available will remain in the internal buffer.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"returns":[[["AudioReceiveStream"]]],"meta":{"line":242,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"pipe","params":[{"name":"destination","optional":false,"type":[[["T"]]]},{"name":"options","optional":true,"type":[[["{"],["\nend",": "],["boolean\n","}"]]]}],"returns":[[["T"]]],"meta":{"line":24,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"prependListener","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":455,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"prependOnceListener","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":463,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"push","params":[{"name":"buffer","optional":false,"type":[[["null"," | "],["Buffer"]]]}],"returns":[[["boolean"]]],"meta":{"line":66,"file":"AudioReceiveStream.ts","path":"src/receive"}},{"name":"rawListeners","description":"Returns a copy of the array of listeners for the event named `eventName`,\nincluding any wrappers (such as those created by `.once()`).","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[["Array","<"],["Function",">"]]]},{"name":"read","description":"The `readable.read()` method pulls some data out of the internal buffer and\nreturns it. If no data available to be read, `null` is returned. By default,\nthe data will be returned as a `Buffer` object unless an encoding has been\nspecified using the `readable.setEncoding()` method or the stream is operating\nin object mode.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"size","description":"Optional argument to specify how much data to read.","optional":true,"type":[[["number"]]]}],"returns":[[["any"]]],"meta":{"line":195,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"removeAllListeners","description":"Removes all listeners, or those of the specified `eventName`.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"event","optional":true,"type":[[["string"," | "],["symbol"]]]}],"returns":[[["AudioReceiveStream"]]]},{"name":"removeListener","params":[{"name":"event","optional":false,"type":[[["'close'"]]]},{"name":"listener","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":471,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"renewEndTimeout","access":"private","params":[{"name":"end","optional":false,"type":[[["{"],["\nbehavior",": "],["Manual\n","} & {"],["\nduration",": "],["number\n","} & {"],["\nbehavior",": "],["AfterSilence"," | "],["AfterInactivity",","],["\nduration",": "],["number\n","} & {"],["\nduration",": "],["number\n","}"]]]}],"returns":[[["void"]]],"meta":{"line":80,"file":"AudioReceiveStream.ts","path":"src/receive"}},{"name":"resume","description":"The `readable.resume()` method causes an explicitly paused `Readable` stream to\nresume emitting `'data'` events, switching the stream into flowing mode.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"returns":[[["AudioReceiveStream"]]],"meta":{"line":261,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"setEncoding","description":"The `readable.setEncoding()` method sets the character encoding for\ndata read from the `Readable` stream.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"encoding","description":"The encoding to use.","optional":false,"type":[[["BufferEncoding"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":220,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"setMaxListeners","description":"By default `EventEmitter`s will print a warning if more than `10` listeners are\nadded for a particular event. This is a useful default that helps finding\nmemory leaks. The `emitter.setMaxListeners()` method allows the limit to be\nmodified for this specific `EventEmitter` instance. The value can be set to`Infinity` (or `0`) to indicate an unlimited number of listeners.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[["AudioReceiveStream"]]]},{"name":"unpipe","description":"The `readable.unpipe()` method detaches a `Writable` stream previously attached\nusing the {@link pipe} method.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"destination","description":"Optional specific stream to unpipe","optional":true,"type":[[["WritableStream"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":305,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"unshift","description":"Passing `chunk` as `null` signals the end of the stream (EOF) and behaves the\nsame as `readable.push(null)`, after which no more data can be written. The EOF\nsignal is put at the end of the buffer and any buffered data will still be\nflushed.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"chunk","description":"Chunk of data to unshift onto the read queue. For streams not operating in object mode, `chunk` must be a string, `Buffer`, `Uint8Array` or `null`. For object mode\nstreams, `chunk` may be any JavaScript value.","optional":false,"type":[[["any"]]]},{"name":"encoding","description":"Encoding of string chunks. Must be a valid `Buffer` encoding, such as `'utf8'` or `'ascii'`.","optional":true,"type":[[["BufferEncoding"]]]}],"returns":[[["void"]]],"meta":{"line":371,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"wrap","description":"Prior to Node.js 0.10, streams did not implement the entire `stream` module API\nas it is currently defined. (See `Compatibility` for more information.)","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"stream","description":"An \"old style\" readable stream","optional":false,"type":[[["ReadableStream"]]]}],"returns":[[["AudioReceiveStream"]]],"meta":{"line":397,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"from","description":"A utility method for creating Readable Streams out of iterators.","scope":"static","params":[{"name":"iterable","optional":false,"type":[[["Iterable","<"],["any","> | "],["AsyncIterable","<"],["any",">"]]]},{"name":"options","optional":true,"type":[[["ReadableOptions"]]]}],"returns":[[["Readable"]]],"meta":{"line":54,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"getEventListeners","description":"Returns a copy of the array of listeners for the event named `eventName`.","see":[],"scope":"static","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"," | "],["DOMEventTarget"]]]},{"name":"name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[["Array","<"],["Function",">"]]],"meta":{"line":262,"file":"events.d.ts","path":"node_modules/@types/node"}},{"name":"isDisturbed","description":"Returns whether the stream has been read from or cancelled.","see":[],"scope":"static","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"stream","optional":false,"type":[[["Readable"," | "],["ReadableStream"]]]}],"returns":[[["boolean"]]],"meta":{"line":59,"file":"stream.d.ts","path":"node_modules/@types/node"}},{"name":"listenerCount","description":"A class method that returns the number of listeners for the given `eventName`registered on the given `emitter`.","see":[],"scope":"static","examples":[],"abstract":false,"deprecated":true,"emits":[],"params":[{"name":"emitter","description":"The emitter to query","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The event name","optional":false,"type":[[["string"," | "],["symbol"]]]}],"returns":[[["number"]]],"meta":{"line":234,"file":"events.d.ts","path":"node_modules/@types/node"}},{"name":"on","description":"```js\nconst { on, EventEmitter } = require('events');","see":[],"scope":"static","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"emitter","optional":false,"type":[[["EventEmitter"]]]},{"name":"eventName","description":"The name of the event being listened for","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[[["AsyncIterableIterator","<"],["any",">"]]],"returnsDescription":"that iterates `eventName` events emitted by the `emitter`","meta":{"line":217,"file":"events.d.ts","path":"node_modules/@types/node"}},{"name":"once","description":"Creates a `Promise` that is fulfilled when the `EventEmitter` emits the given\nevent or that is rejected if the `EventEmitter` emits `'error'` while waiting.\nThe `Promise` will resolve with an array of all the arguments emitted to the\ngiven event.","see":[],"scope":"static","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"emitter","optional":false,"type":[[["NodeEventTarget"]]]},{"name":"eventName","optional":false,"type":[[["string"," | "],["symbol"]]]},{"name":"options","optional":true,"type":[[["StaticEventEmitterOptions"]]]}],"returns":[[["Promise","<"],["Array","<"],["any",">>"]]],"meta":{"line":157,"file":"events.d.ts","path":"node_modules/@types/node"}}],"meta":{"line":49,"file":"AudioReceiveStream.ts","path":"src/receive"}},{"name":"AudioResource","description":"Represents an audio resource that can be played by an audio player.","construct":{"name":"constructor","params":[{"name":"edges","optional":false,"type":[[["readonly"," "],["Array","<"],["Edge",">"]]]},{"name":"streams","optional":false,"type":[[["readonly"," "],["Array","<"],["Readable",">"]]]},{"name":"metadata","optional":false,"type":[[["T"]]]},{"name":"silencePaddingFrames","optional":false,"type":[[["number"]]]}],"returns":[[["AudioResource","<"],["T",">"]]],"meta":{"line":98,"file":"AudioResource.ts","path":"src/audio"}},"props":[{"name":"audioPlayer","description":"The audio player that the resource is subscribed to, if any.","type":[[["AudioPlayer"]]],"meta":{"line":76,"file":"AudioResource.ts","path":"src/audio"}},{"name":"edges","description":"The pipeline used to convert the input stream into a playable format. For example, this may\ncontain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component\nfor resources with inline volume transformation enabled.","readonly":true,"type":[[["readonly"," "],["Array","<"],["Edge",">"]]],"meta":{"line":54,"file":"AudioResource.ts","path":"src/audio"}},{"name":"encoder","description":"If using an Opus encoder to create this audio resource, then this will be a prism-media opus.Encoder.\nYou can use this to control settings such as bitrate, FEC, PLP.","readonly":true,"type":[[["Encoder"]]],"meta":{"line":71,"file":"AudioResource.ts","path":"src/audio"}},{"name":"metadata","description":"Optional metadata that can be used to identify the resource.","type":[[["T"]]],"meta":{"line":59,"file":"AudioResource.ts","path":"src/audio"}},{"name":"playStream","description":"An object-mode Readable stream that emits Opus packets. This is what is played by audio players.","readonly":true,"type":[[["Readable"]]],"meta":{"line":47,"file":"AudioResource.ts","path":"src/audio"}},{"name":"playbackDuration","description":"The playback duration of this audio resource, given in milliseconds.","default":"0","type":[[["number"]]],"meta":{"line":81,"file":"AudioResource.ts","path":"src/audio"}},{"name":"silencePaddingFrames","description":"The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.","readonly":true,"type":[[["number"]]],"meta":{"line":91,"file":"AudioResource.ts","path":"src/audio"}},{"name":"silenceRemaining","description":"The number of remaining silence frames to play. If -1, the frames have not yet started playing.","default":"-1","type":[[["number"]]],"meta":{"line":96,"file":"AudioResource.ts","path":"src/audio"}},{"name":"started","description":"Whether or not the stream for this resource has started (data has become readable)","default":"false","type":[[["boolean"]]],"meta":{"line":86,"file":"AudioResource.ts","path":"src/audio"}},{"name":"volume","description":"If the resource was created with inline volume transformation enabled, then this will be a\nprism-media VolumeTransformer. You can use this to alter the volume of the stream.","readonly":true,"type":[[["VolumeTransformer"]]],"meta":{"line":65,"file":"AudioResource.ts","path":"src/audio"}},{"name":"ended","description":"Whether this resource has ended or not.","readonly":true,"type":[[["boolean"]]],"meta":{"line":132,"file":"AudioResource.ts","path":"src/audio"}},{"name":"readable","description":"Whether this resource is readable. If the underlying resource is no longer readable, this will still return true\nwhile there are silence padding frames left to play.","readonly":true,"type":[[["boolean"]]],"meta":{"line":119,"file":"AudioResource.ts","path":"src/audio"}}],"methods":[{"name":"read","description":"Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration\nis incremented.","see":[],"access":"private","examples":[],"abstract":false,"deprecated":false,"emits":[],"returns":[[["null"," | "],["Buffer"]]],"meta":{"line":147,"file":"AudioResource.ts","path":"src/audio"}}],"meta":{"line":43,"file":"AudioResource.ts","path":"src/audio"}},{"name":"PlayerSubscription","description":"Represents a subscription of a voice connection to an audio player, allowing\nthe audio player to play audio on the voice connection.","construct":{"name":"constructor","params":[{"name":"connection","optional":false,"type":[[["VoiceConnection"]]]},{"name":"player","optional":false,"type":[[["AudioPlayer"]]]}],"returns":[[["PlayerSubscription"]]],"meta":{"line":20,"file":"PlayerSubscription.ts","path":"src/audio"}},"props":[{"name":"connection","description":"The voice connection of this subscription.","readonly":true,"type":[[["VoiceConnection"]]],"meta":{"line":13,"file":"PlayerSubscription.ts","path":"src/audio"}},{"name":"player","description":"The audio player of this subscription.","readonly":true,"type":[[["AudioPlayer"]]],"meta":{"line":18,"file":"PlayerSubscription.ts","path":"src/audio"}}],"methods":[{"name":"unsubscribe","description":"Unsubscribes the connection from the audio player, meaning that the\naudio player cannot stream audio to it until a new subscription is made.","returns":[[["void"]]],"meta":{"line":29,"file":"PlayerSubscription.ts","path":"src/audio"}}],"meta":{"line":9,"file":"PlayerSubscription.ts","path":"src/audio"}},{"name":"SSRCMap","description":"Maps audio SSRCs to data of users in voice connections.","extends":["TypedEmitter<SSRCMapEvents>"],"construct":{"name":"constructor","returns":[[["SSRCMap"]]],"meta":{"line":43,"file":"SSRCMap.ts","path":"src/receive"}},"props":[{"name":"map","description":"The underlying map.","access":"private","readonly":true,"type":[[["Map","<"],["number",", "],["VoiceUserData",">"]]],"meta":{"line":41,"file":"SSRCMap.ts","path":"src/receive"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":10,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}}],"methods":[{"name":"addListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SSRCMapEvents","["],["U","]"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":11,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"delete","description":"Deletes the stored voice data about a user.","params":[{"name":"target","description":"The target of the delete operation, either their audio SSRC or user id","optional":false,"type":[[["string"," | "],["number"]]]}],"returns":[[["undefined"," | "],["VoiceUserData"]]],"returnsDescription":"The data that was deleted, if any","meta":{"line":92,"file":"SSRCMap.ts","path":"src/receive"}},{"name":"emit","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"args","optional":false,"type":[[["Parameters","<"],["SSRCMapEvents","["],["U","]>"]]]}],"returns":[[["boolean"]]],"meta":{"line":19,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"eventNames","returns":[[["Array","<"],["U",">"]]],"meta":{"line":20,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"get","description":"Gets the stored voice data of a user.","params":[{"name":"target","description":"The target, either their user id or audio SSRC","optional":false,"type":[[["string"," | "],["number"]]]}],"returns":[[["undefined"," | "],["VoiceUserData"]]],"meta":{"line":71,"file":"SSRCMap.ts","path":"src/receive"}},{"name":"getMaxListeners","returns":[[["number"]]],"meta":{"line":24,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listenerCount","params":[{"name":"type","optional":false,"type":[[["keyof"," "],["SSRCMapEvents"]]]}],"returns":[[["number"]]],"meta":{"line":21,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["SSRCMapEvents","["],["U","]>"]]],"meta":{"line":22,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"off","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SSRCMapEvents","["],["U","]"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":18,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"on","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SSRCMapEvents","["],["U","]"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":17,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"once","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SSRCMapEvents","["],["U","]"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":16,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"prependListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SSRCMapEvents","["],["U","]"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":12,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"prependOnceListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SSRCMapEvents","["],["U","]"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":13,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"rawListeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["SSRCMapEvents","["],["U","]>"]]],"meta":{"line":23,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"removeAllListeners","params":[{"name":"event","optional":true,"type":[[["keyof"," "],["SSRCMapEvents"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":15,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"removeListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SSRCMapEvents","["],["U","]"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":14,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"setMaxListeners","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[["SSRCMap"]]],"meta":{"line":25,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"update","description":"Updates the map with new user data","params":[{"name":"data","description":"The data to update with","optional":false,"type":[[["VoiceUserData"]]]}],"returns":[[["void"]]],"meta":{"line":53,"file":"SSRCMap.ts","path":"src/receive"}}],"meta":{"line":37,"file":"SSRCMap.ts","path":"src/receive"}},{"name":"SpeakingMap","description":"Tracks the speaking states of users in a voice channel.","extends":["TypedEmitter<SpeakingMapEvents>"],"construct":{"name":"constructor","returns":[[["SpeakingMap"]]],"meta":{"line":35,"file":"SpeakingMap.ts","path":"src/receive"}},"props":[{"name":"speakingTimeouts","access":"private","readonly":true,"type":[[["Map","<"],["string",", "],["Timeout",">"]]],"meta":{"line":33,"file":"SpeakingMap.ts","path":"src/receive"}},{"name":"users","description":"The currently speaking users, mapped to the milliseconds since UNIX epoch at which they started speaking.","readonly":true,"type":[[["Map","<"],["string",", "],["number",">"]]],"meta":{"line":31,"file":"SpeakingMap.ts","path":"src/receive"}},{"name":"DELAY","description":"The delay after a packet is received from a user until they're marked as not speaking anymore.","scope":"static","readonly":true,"default":"100","type":[[["100"]]],"meta":{"line":26,"file":"SpeakingMap.ts","path":"src/receive"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":10,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}}],"methods":[{"name":"addListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SpeakingMapEvents","["],["U","]"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":11,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"emit","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"args","optional":false,"type":[[["Parameters","<"],["SpeakingMapEvents","["],["U","]>"]]]}],"returns":[[["boolean"]]],"meta":{"line":19,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"eventNames","returns":[[["Array","<"],["U",">"]]],"meta":{"line":20,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"getMaxListeners","returns":[[["number"]]],"meta":{"line":24,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listenerCount","params":[{"name":"type","optional":false,"type":[[["keyof"," "],["SpeakingMapEvents"]]]}],"returns":[[["number"]]],"meta":{"line":21,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["SpeakingMapEvents","["],["U","]>"]]],"meta":{"line":22,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"off","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SpeakingMapEvents","["],["U","]"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":18,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"on","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SpeakingMapEvents","["],["U","]"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":17,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"onPacket","params":[{"name":"userId","optional":false,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":41,"file":"SpeakingMap.ts","path":"src/receive"}},{"name":"once","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SpeakingMapEvents","["],["U","]"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":16,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"prependListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SpeakingMapEvents","["],["U","]"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":12,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"prependOnceListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SpeakingMapEvents","["],["U","]"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":13,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"rawListeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["SpeakingMapEvents","["],["U","]>"]]],"meta":{"line":23,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"removeAllListeners","params":[{"name":"event","optional":true,"type":[[["keyof"," "],["SpeakingMapEvents"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":15,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"removeListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["SpeakingMapEvents","["],["U","]"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":14,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"setMaxListeners","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[["SpeakingMap"]]],"meta":{"line":25,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"startTimeout","access":"private","params":[{"name":"userId","optional":false,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":52,"file":"SpeakingMap.ts","path":"src/receive"}}],"meta":{"line":22,"file":"SpeakingMap.ts","path":"src/receive"}},{"name":"VoiceConnection","description":"A connection to the voice server of a Guild, can be used to play audio in voice channels.","extends":["TypedEmitter<VoiceConnectionEvents>"],"construct":{"name":"constructor","description":"Creates a new voice connection.","params":[{"name":"joinConfig","description":"The data required to establish the voice connection","optional":false,"type":[[["JoinConfig"]]]},{"name":"options","description":"The options used to create this voice connection","optional":false,"type":[[["CreateVoiceConnectionOptions"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":223,"file":"VoiceConnection.ts","path":"src"}},"props":[{"name":"_state","description":"The state of the voice connection.","access":"private","type":[[["VoiceConnectionState"]]],"meta":{"line":188,"file":"VoiceConnection.ts","path":"src"}},{"name":"debug","description":"The debug logger function, if debugging is enabled.","access":"private","readonly":true,"type":[[["null"," | ("],["message",": "],["string",") => "],["void"]]],"meta":{"line":215,"file":"VoiceConnection.ts","path":"src"}},{"name":"joinConfig","description":"A configuration storing all the data needed to reconnect to a Guild's voice server.","see":[],"access":"private","readonly":true,"abstract":false,"deprecated":false,"type":[[["JoinConfig"]]],"meta":{"line":195,"file":"VoiceConnection.ts","path":"src"}},{"name":"packets","description":"The two packets needed to successfully establish a voice connection. They are received\nfrom the main Discord gateway after signalling to change the voice state.","access":"private","readonly":true,"type":[[["{"],["\nserver",": "],["undefined"," | "],["GatewayVoiceServerUpdateDispatchData",","],["\nstate",": "],["undefined"," | "],["GatewayVoiceState\n","}"]]],"meta":{"line":201,"file":"VoiceConnection.ts","path":"src"}},{"name":"receiver","description":"The receiver of this voice connection. You should join the voice channel with `selfDeaf` set\nto false for this feature to work properly.","readonly":true,"type":[[["VoiceReceiver"]]],"meta":{"line":210,"file":"VoiceConnection.ts","path":"src"}},{"name":"rejoinAttempts","description":"The number of consecutive rejoin attempts. Initially 0, and increments for each rejoin.\nWhen a connection is successfully established, it resets to 0.","type":[[["number"]]],"meta":{"line":183,"file":"VoiceConnection.ts","path":"src"}},{"name":"defaultMaxListeners","scope":"static","type":[[["number"]]],"meta":{"line":10,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"ping","description":"The latest ping (in milliseconds) for the WebSocket connection and audio playback for this voice\nconnection, if this data is available.","see":[],"readonly":true,"abstract":false,"deprecated":false,"type":[[["{"],["\nudp",": "],["undefined"," | "],["number",","],["\nws",": "],["undefined"," | "],["number\n","}"]]],"meta":{"line":653,"file":"VoiceConnection.ts","path":"src"}},{"name":"state","description":"The current state of the voice connection.","readonly":false,"type":[[["VoiceConnectionState"]]],"meta":{"line":255,"file":"VoiceConnection.ts","path":"src"}}],"methods":[{"name":"addListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["VoiceConnectionEvents","["],["U","]"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":11,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"addServerPacket","description":"Registers a `VOICE_SERVER_UPDATE` packet to the voice connection. This will cause it to reconnect using the\nnew data provided in the packet.","access":"private","params":[{"name":"packet","description":"The received `VOICE_SERVER_UPDATE` packet","optional":false,"type":[[["GatewayVoiceServerUpdateDispatchData"]]]}],"returns":[[["void"]]],"meta":{"line":314,"file":"VoiceConnection.ts","path":"src"}},{"name":"addStatePacket","description":"Registers a `VOICE_STATE_UPDATE` packet to the voice connection. Most importantly, it stores the id of the\nchannel that the client is connected to.","access":"private","params":[{"name":"packet","description":"The received `VOICE_STATE_UPDATE` packet","optional":false,"type":[[["GatewayVoiceState"]]]}],"returns":[[["void"]]],"meta":{"line":333,"file":"VoiceConnection.ts","path":"src"}},{"name":"configureNetworking","description":"Attempts to configure a networking instance for this voice connection using the received packets.\nBoth packets are required, and any existing networking instance will be destroyed.","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"returns":[[["void"]]],"meta":{"line":382,"file":"VoiceConnection.ts","path":"src"}},{"name":"destroy","description":"Destroys the VoiceConnection, preventing it from connecting to voice again.\nThis method should be called when you no longer require the VoiceConnection to\nprevent memory leaks.","params":[{"name":"adapterAvailable","description":"Whether the adapter can be used","optional":true,"default":"true","type":[[["boolean"]]]}],"returns":[[["void"]]],"meta":{"line":530,"file":"VoiceConnection.ts","path":"src"}},{"name":"disconnect","description":"Disconnects the VoiceConnection, allowing the possibility of rejoining later on.","returns":[[["boolean"]]],"returnsDescription":"`true` if the connection was successfully disconnected","meta":{"line":550,"file":"VoiceConnection.ts","path":"src"}},{"name":"dispatchAudio","description":"Dispatches the previously prepared audio packet (if any)","returns":[[["undefined"," | "],["boolean"]]],"meta":{"line":505,"file":"VoiceConnection.ts","path":"src"}},{"name":"emit","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"args","optional":false,"type":[[["Parameters","<"],["VoiceConnectionEvents","["],["U","]>"]]]}],"returns":[[["boolean"]]],"meta":{"line":19,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"eventNames","returns":[[["Array","<"],["U",">"]]],"meta":{"line":20,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"getMaxListeners","returns":[[["number"]]],"meta":{"line":24,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listenerCount","params":[{"name":"type","optional":false,"type":[[["VoiceConnectionStatus"," | "],["'error'"," | "],["'debug'"," | "],["'stateChange'"]]]}],"returns":[[["number"]]],"meta":{"line":21,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"listeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["VoiceConnectionEvents","["],["U","]>"]]],"meta":{"line":22,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"off","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["VoiceConnectionEvents","["],["U","]"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":18,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"on","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["VoiceConnectionEvents","["],["U","]"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":17,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"onNetworkingClose","description":"Called when the networking instance for this connection closes. If the close code is 4014 (do not reconnect),\nthe voice connection will transition to the Disconnected state which will store the close code. You can\ndecide whether or not to reconnect when this occurs by listening for the state change and calling reconnect().","see":[],"access":"private","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"code","description":"The close code","optional":false,"type":[[["number"]]]}],"returns":[[["void"]]],"meta":{"line":421,"file":"VoiceConnection.ts","path":"src"}},{"name":"onNetworkingDebug","description":"Propagates debug messages from the underlying network instance.","access":"private","params":[{"name":"message","description":"The debug message to propagate","optional":false,"type":[[["string"]]]}],"returns":[[["void"]]],"meta":{"line":487,"file":"VoiceConnection.ts","path":"src"}},{"name":"onNetworkingError","description":"Propagates errors from the underlying network instance.","access":"private","params":[{"name":"error","description":"The error to propagate","optional":false,"type":[[["Error"]]]}],"returns":[[["void"]]],"meta":{"line":478,"file":"VoiceConnection.ts","path":"src"}},{"name":"onNetworkingStateChange","description":"Called when the state of the networking instance changes. This is used to derive the state of the voice connection.","access":"private","params":[{"name":"oldState","description":"The previous state","optional":false,"type":[[["NetworkingState"]]]},{"name":"newState","description":"The new state","optional":false,"type":[[["NetworkingState"]]]}],"returns":[[["void"]]],"meta":{"line":454,"file":"VoiceConnection.ts","path":"src"}},{"name":"onSubscriptionRemoved","description":"Called when a subscription of this voice connection to an audio player is removed.","access":"private","params":[{"name":"subscription","description":"The removed subscription","optional":false,"type":[[["PlayerSubscription"]]]}],"returns":[[["void"]]],"meta":{"line":675,"file":"VoiceConnection.ts","path":"src"}},{"name":"once","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["VoiceConnectionEvents","["],["U","]"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":16,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"playOpusPacket","description":"Prepares an audio packet and dispatches it immediately.","params":[{"name":"buffer","description":"The Opus packet to play","optional":false,"type":[[["Buffer"]]]}],"returns":[[["undefined"," | "],["boolean"]]],"meta":{"line":516,"file":"VoiceConnection.ts","path":"src"}},{"name":"prepareAudioPacket","description":"Prepares an audio packet for dispatch.","params":[{"name":"buffer","description":"The Opus packet to prepare","optional":false,"type":[[["Buffer"]]]}],"returns":[[["undefined"," | "],["Buffer"]]],"meta":{"line":496,"file":"VoiceConnection.ts","path":"src"}},{"name":"prependListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["VoiceConnectionEvents","["],["U","]"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":12,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"prependOnceListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["VoiceConnectionEvents","["],["U","]"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":13,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"rawListeners","params":[{"name":"type","optional":false,"type":[[["U"]]]}],"returns":[[["Array","<"],["VoiceConnectionEvents","["],["U","]>"]]],"meta":{"line":23,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"rejoin","description":"Attempts to rejoin (better explanation soon:tm:)","see":[],"examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"joinConfig","optional":true,"type":[[["Omit","<"],["JoinConfig",", "],["'guildId'"," | "],["'group'",">"]]]}],"returns":[[["boolean"]]],"meta":{"line":585,"file":"VoiceConnection.ts","path":"src"}},{"name":"removeAllListeners","params":[{"name":"event","optional":true,"type":[[["VoiceConnectionStatus"," | "],["'error'"," | "],["'debug'"," | "],["'stateChange'"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":15,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"removeListener","params":[{"name":"event","optional":false,"type":[[["U"]]]},{"name":"listener","optional":false,"type":[[["VoiceConnectionEvents","["],["U","]"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":14,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"setMaxListeners","params":[{"name":"n","optional":false,"type":[[["number"]]]}],"returns":[[["VoiceConnection"]]],"meta":{"line":25,"file":"index.d.ts","path":"node_modules/tiny-typed-emitter/lib"}},{"name":"setSpeaking","description":"Updates the speaking status of the voice connection. This is used when audio players are done playing audio,\nand need to signal that the connection is no longer playing audio.","params":[{"name":"enabled","description":"Whether or not to show as speaking","optional":false,"type":[[["boolean"]]]}],"returns":[[["false"," | "],["void"]]],"meta":{"line":619,"file":"VoiceConnection.ts","path":"src"}},{"name":"subscribe","description":"Subscribes to an audio player, allowing the player to play audio on this voice connection.","params":[{"name":"player","description":"The audio player to subscribe to","optional":false,"type":[[["AudioPlayer"]]]}],"returns":[[["undefined"," | "],["PlayerSubscription"]]],"returnsDescription":"The created subscription","meta":{"line":631,"file":"VoiceConnection.ts","path":"src"}},{"name":"updateReceiveBindings","description":"Called when the networking state changes, and the new ws/udp packet/message handlers need to be rebound\nto the new instances.","access":"private","params":[{"name":"newState","description":"The new networking state","optional":false,"type":[[["NetworkingState"]]]},{"name":"oldState","description":"The old networking state, if there is one","optional":true,"type":[[["NetworkingState"]]]}],"returns":[[["void"]]],"meta":{"line":352,"file":"VoiceConnection.ts","path":"src"}}],"meta":{"line":178,"file":"VoiceConnection.ts","path":"src"}},{"name":"VoiceReceiver","description":"Attaches to a VoiceConnection, allowing you to receive audio packets from other\nusers that are speaking.","see":[],"abstract":false,"deprecated":false,"construct":{"name":"constructor","params":[{"name":"voiceConnection","optional":false,"type":[[["VoiceConnection"]]]}],"returns":[[["VoiceReceiver"]]],"meta":{"line":47,"file":"VoiceReceiver.ts","path":"src/receive"}},"props":[{"name":"connectionData","description":"The connection data of the receiver.","see":[],"access":"private","abstract":false,"deprecated":false,"type":[[["Partial","<"],["ConnectionData",">"]]],"meta":{"line":40,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"speaking","description":"The speaking map of the receiver.","readonly":true,"type":[[["SpeakingMap"]]],"meta":{"line":45,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"ssrcMap","description":"Maps SSRCs to Discord user ids.","readonly":true,"type":[[["SSRCMap"]]],"meta":{"line":28,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"subscriptions","description":"The current audio subscriptions of this receiver.","readonly":true,"type":[[["Map","<"],["string",", "],["AudioReceiveStream",">"]]],"meta":{"line":33,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"voiceConnection","description":"The attached connection of this receiver.","readonly":true,"type":[[["VoiceConnection"]]],"meta":{"line":23,"file":"VoiceReceiver.ts","path":"src/receive"}}],"methods":[{"name":"decrypt","access":"private","params":[{"name":"buffer","optional":false,"type":[[["Buffer"]]]},{"name":"mode","optional":false,"type":[[["string"]]]},{"name":"nonce","optional":false,"type":[[["Buffer"]]]},{"name":"secretKey","optional":false,"type":[[["Uint8Array"]]]}],"returns":[[["undefined"," | "],["Buffer"]]],"meta":{"line":88,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"onUdpMessage","description":"Called when the UDP socket of the attached connection receives a message.","see":[],"access":"private","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"msg","description":"The received message","optional":false,"type":[[["Buffer"]]]}],"returns":[[["void"]]],"meta":{"line":148,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"onWsPacket","description":"Called when a packet is received on the attached connection's WebSocket.","see":[],"access":"private","examples":[],"abstract":false,"deprecated":false,"emits":[],"params":[{"name":"packet","description":"The received packet","optional":false,"type":[[["any"]]]}],"returns":[[["void"]]],"meta":{"line":65,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"parsePacket","description":"Parses an audio packet, decrypting it to yield an Opus packet.","access":"private","params":[{"name":"buffer","description":"The buffer to parse","optional":false,"type":[[["Buffer"]]]},{"name":"mode","description":"The encryption mode","optional":false,"type":[[["string"]]]},{"name":"nonce","description":"The nonce buffer used by the connection for encryption","optional":false,"type":[[["Buffer"]]]},{"name":"secretKey","description":"The secret key used by the connection for encryption","optional":false,"type":[[["Uint8Array"]]]}],"returns":[[["undefined"," | "],["Buffer"]]],"returnsDescription":"The parsed Opus packet","meta":{"line":117,"file":"VoiceReceiver.ts","path":"src/receive"}},{"name":"subscribe","description":"Creates a subscription for the given user id.","params":[{"name":"userId","optional":false,"type":[[["string"]]]},{"name":"options","optional":true,"type":[[["Partial","<"],["AudioReceiveStreamOptions",">"]]]}],"returns":[[["AudioReceiveStream"]]],"returnsDescription":"A readable stream of Opus packets received from the target","meta":{"line":182,"file":"VoiceReceiver.ts","path":"src/receive"}}],"meta":{"line":19,"file":"VoiceReceiver.ts","path":"src/receive"}}],"typedefs":[{"name":"AudioPlayerStatus","meta":{"line":33,"file":"AudioPlayer.ts","path":"src/audio"},"props":[{"name":"AutoPaused","description":"When the player has paused itself. Only possible with the \"pause\" no subscriber behavior.","type":[[["\"autopaused\""]]]},{"name":"Buffering","description":"When the player is waiting for an audio resource to become readable before transitioning to Playing.","type":[[["\"buffering\""]]]},{"name":"Idle","description":"When there is currently no resource for the player to be playing.","type":[[["\"idle\""]]]},{"name":"Paused","description":"When the player has been manually paused.","type":[[["\"paused\""]]]},{"name":"Playing","description":"When the player is actively playing an audio resource.","type":[[["\"playing\""]]]}]},{"name":"EndBehaviorType","description":"The different behaviors an audio receive stream can have for deciding when to end.","meta":{"line":7,"file":"AudioReceiveStream.ts","path":"src/receive"},"props":[{"name":"AfterInactivity","description":"The stream will end after a given time period of no audio packets.","type":[[["2"]]]},{"name":"AfterSilence","description":"The stream will end after a given time period of silence/no audio packets.","type":[[["1"]]]},{"name":"Manual","description":"The stream will only end when manually destroyed.","type":[[["0"]]]}]},{"name":"NoSubscriberBehavior","description":"Describes the behavior of the player when an audio packet is played but there are no available\nvoice connections to play to.","meta":{"line":16,"file":"AudioPlayer.ts","path":"src/audio"},"props":[{"name":"Pause","description":"Pauses playing the stream until a voice connection becomes available.","type":[[["\"pause\""]]]},{"name":"Play","description":"Continues to play through the resource regardless.","type":[[["\"play\""]]]},{"name":"Stop","description":"The player stops and enters the Idle state.","type":[[["\"stop\""]]]}]},{"name":"StreamType","description":"The different types of stream that can exist within the pipeline.","see":[],"deprecated":false,"meta":{"line":35,"file":"TransformerGraph.ts","path":"src/audio"},"props":[{"name":"Arbitrary","type":[[["\"arbitrary\""]]]},{"name":"OggOpus","type":[[["\"ogg/opus\""]]]},{"name":"Opus","type":[[["\"opus\""]]]},{"name":"Raw","type":[[["\"raw\""]]]},{"name":"WebmOpus","type":[[["\"webm/opus\""]]]}]},{"name":"VoiceConnectionDisconnectReason","description":"The reasons a voice connection can be in the disconnected state.","meta":{"line":62,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"AdapterUnavailable","description":"When the adapter was unable to send a message requested by the VoiceConnection.","type":[[["1"]]]},{"name":"EndpointRemoved","description":"When a VOICE_SERVER_UPDATE packet is received with a null endpoint, causing the connection to be severed.","type":[[["2"]]]},{"name":"Manual","description":"When a manual disconnect was requested.","type":[[["3"]]]},{"name":"WebSocketClose","description":"When the WebSocket connection has been closed.","type":[[["0"]]]}]},{"name":"VoiceConnectionStatus","description":"The various status codes a voice connection can hold at any one time.","meta":{"line":22,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"Connecting","description":"The `VOICE_SERVER_UPDATE` and `VOICE_STATE_UPDATE` packets have been received, now attempting to establish a voice connection.","type":[[["\"connecting\""]]]},{"name":"Destroyed","description":"The voice connection has been destroyed and untracked, it cannot be reused.","type":[[["\"destroyed\""]]]},{"name":"Disconnected","description":"The voice connection has either been severed or not established.","type":[[["\"disconnected\""]]]},{"name":"Ready","description":"A voice connection has been established, and is ready to be used.","type":[[["\"ready\""]]]},{"name":"Signalling","description":"Sending a packet to the main Discord gateway to indicate we want to change our voice state.","type":[[["\"signalling\""]]]}]},{"name":"AudioPlayerBufferingState","description":"The state that an AudioPlayer is in when it is waiting for a resource to become readable. Once this\nhappens, the AudioPlayer will enter the Playing state. If the resource ends/errors before this, then\nit will re-enter the Idle state.","meta":{"line":83,"file":"AudioPlayer.ts","path":"src/audio"},"props":[{"name":"resource","description":"The resource that the AudioPlayer is waiting for","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]},{"name":"status","optional":false,"type":[[["Buffering"]]]},{"name":"onFailureCallback","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"onReadableCallback","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"onStreamError","optional":false,"type":[[["("],["error",": "],["Error",") => "],["void"]]]}]},{"name":"AudioPlayerIdleState","description":"The state that an AudioPlayer is in when it has no resource to play. This is the starting state.","meta":{"line":74,"file":"AudioPlayer.ts","path":"src/audio"},"props":[{"name":"status","optional":false,"type":[[["Idle"]]]}]},{"name":"AudioPlayerPausedState","description":"The state that an AudioPlayer is in when it has either been explicitly paused by the user, or done\nautomatically by the AudioPlayer itself if there are no available subscribers.","meta":{"line":123,"file":"AudioPlayer.ts","path":"src/audio"},"props":[{"name":"playbackDuration","description":"The playback duration in milliseconds of the current audio resource. This includes filler silence packets\nthat have been played when the resource was buffering.","optional":false,"type":[[["number"]]]},{"name":"resource","description":"The current resource of the audio player.","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]},{"name":"silencePacketsRemaining","description":"How many silence packets still need to be played to avoid audio interpolation due to the stream suddenly pausing.","optional":false,"type":[[["number"]]]},{"name":"status","optional":false,"type":[[["Paused"," | "],["AutoPaused"]]]},{"name":"onStreamError","optional":false,"type":[[["("],["error",": "],["Error",") => "],["void"]]]}]},{"name":"AudioPlayerPlayingState","description":"The state that an AudioPlayer is in when it is actively playing an AudioResource. When playback ends,\nit will enter the Idle state.","meta":{"line":98,"file":"AudioPlayer.ts","path":"src/audio"},"props":[{"name":"missedFrames","description":"The number of consecutive times that the audio resource has been unable to provide an Opus frame.","optional":false,"type":[[["number"]]]},{"name":"playbackDuration","description":"The playback duration in milliseconds of the current audio resource. This includes filler silence packets\nthat have been played when the resource was buffering.","optional":false,"type":[[["number"]]]},{"name":"resource","description":"The resource that is being played.","optional":false,"type":[[["AudioResource","<"],["unknown",">"]]]},{"name":"status","optional":false,"type":[[["Playing"]]]},{"name":"onStreamError","optional":false,"type":[[["("],["error",": "],["Error",") => "],["void"]]]}]},{"name":"AudioReceiveStreamOptions","meta":{"line":33,"file":"AudioReceiveStream.ts","path":"src/receive"},"props":[{"name":"autoDestroy","optional":true,"type":[[["boolean"]]]},{"name":"emitClose","optional":true,"type":[[["boolean"]]]},{"name":"encoding","optional":true,"type":[[["BufferEncoding"]]]},{"name":"end","optional":false,"type":[[["EndBehavior"]]]},{"name":"highWaterMark","optional":true,"type":[[["number"]]]},{"name":"objectMode","optional":true,"type":[[["boolean"]]]},{"name":"signal","description":"When provided the corresponding `AbortController` can be used to cancel an asynchronous action.","optional":true,"type":[[["AbortSignal"]]]},{"name":"construct","optional":true,"type":[[["("],["callback",": ("],["error",": "],["null"," | "],["Error",") => "],["void",") => "],["void"]]]},{"name":"destroy","optional":true,"type":[[["("],["error",": "],["null"," | "],["Error",", "],["callback",": ("],["error",": "],["null"," | "],["Error",") => "],["void",") => "],["void"]]]},{"name":"read","optional":true,"type":[[["("],["size",": "],["number",") => "],["void"]]]}]},{"name":"CreateAudioPlayerOptions","description":"Options that can be passed when creating an audio player, used to specify its behavior.","meta":{"line":63,"file":"AudioPlayer.ts","path":"src/audio"},"props":[{"name":"behaviors","optional":true,"type":[[["{"],["\nmaxMissedFrames",": "],["number",","],["\nnoSubscriber",": "],["NoSubscriberBehavior\n","}"]]]},{"name":"debug","optional":true,"type":[[["boolean"]]]}]},{"name":"CreateAudioResourceOptions","description":"Options that are set when creating a new audio resource.","meta":{"line":12,"file":"AudioResource.ts","path":"src/audio"},"props":[{"name":"inlineVolume","description":"Whether or not inline volume should be enabled. If enabled, you will be able to change the volume\nof the stream on-the-fly. However, this also increases the performance cost of playback. Defaults to `false`.","optional":true,"type":[[["boolean"]]]},{"name":"inputType","description":"The type of the input stream. Defaults to `StreamType.Arbitrary`.","optional":true,"type":[[["StreamType"]]]},{"name":"metadata","description":"Optional metadata that can be attached to the resource (e.g. track title, random id).\nThis is useful for identification purposes when the resource is passed around in events.\nSee {@link AudioResource.metadata}","optional":true,"type":[[["T"]]]},{"name":"silencePaddingFrames","description":"The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.\nDefaults to 5.","optional":true,"type":[[["number"]]]}]},{"name":"CreateVoiceConnectionOptions","description":"The options that can be given when creating a voice connection.","meta":{"line":8,"file":"joinVoiceChannel.ts","path":"src"},"props":[{"name":"adapterCreator","optional":false,"type":[[["DiscordGatewayAdapterCreator"]]]},{"name":"debug","description":"If true, debug messages will be enabled for the voice connection and its\nrelated components. Defaults to false.","optional":true,"type":[[["boolean"]]]}]},{"name":"DiscordGatewayAdapterImplementerMethods","description":"Methods that are provided by the implementer of a Discord gateway DiscordGatewayAdapter.","meta":{"line":29,"file":"adapter.ts","path":"src/util"},"props":[{"name":"destroy","description":"This will be called by @discordjs/voice when the adapter can safely be destroyed as it will no\nlonger be used.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"sendPayload","description":"Implement this method such that the given payload is sent to the main Discord gateway connection.","optional":false,"type":[[["("],["payload",": "],["any",") => "],["boolean"]]]}]},{"name":"DiscordGatewayAdapterLibraryMethods","description":"Methods that are provided by the @discordjs/voice library to implementations of\nDiscord gateway DiscordGatewayAdapters.","meta":{"line":7,"file":"adapter.ts","path":"src/util"},"props":[{"name":"destroy","description":"Call this when the adapter can no longer be used (e.g. due to a disconnect from the main gateway)","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["void"]]]},{"name":"onVoiceServerUpdate","description":"Call this when you receive a VOICE_SERVER_UPDATE payload that is relevant to the adapter.","optional":false,"type":[[["("],["data",": "],["GatewayVoiceServerUpdateDispatchData",") => "],["void"]]]},{"name":"onVoiceStateUpdate","description":"Call this when you receive a VOICE_STATE_UPDATE payload that is relevant to the adapter.","optional":false,"type":[[["("],["data",": "],["GatewayVoiceState",") => "],["void"]]]}]},{"name":"JoinConfig","meta":{"line":5,"file":"DataStore.ts","path":"src"},"props":[{"name":"channelId","optional":false,"type":[[["null"," | "],["string"]]]},{"name":"group","optional":false,"type":[[["string"]]]},{"name":"guildId","optional":false,"type":[[["string"]]]},{"name":"selfDeaf","optional":false,"type":[[["boolean"]]]},{"name":"selfMute","optional":false,"type":[[["boolean"]]]}]},{"name":"JoinVoiceChannelOptions","description":"The options that can be given when joining a voice channel.","meta":{"line":21,"file":"joinVoiceChannel.ts","path":"src"},"props":[{"name":"channelId","description":"The id of the Discord voice channel to join.","optional":false,"type":[[["string"]]]},{"name":"group","description":"An optional group identifier for the voice connection.","optional":true,"type":[[["string"]]]},{"name":"guildId","description":"The id of the guild that the voice channel belongs to.","optional":false,"type":[[["string"]]]},{"name":"selfDeaf","description":"Whether to join the channel deafened (defaults to true)","optional":true,"type":[[["boolean"]]]},{"name":"selfMute","description":"Whether to join the channel muted (defaults to true)","optional":true,"type":[[["boolean"]]]}]},{"name":"ProbeInfo","description":"The resulting information after probing an audio stream","meta":{"line":22,"file":"demuxProbe.ts","path":"src/util"},"props":[{"name":"stream","description":"The readable audio stream to use. You should use this rather than the input stream, as the probing\nfunction can sometimes read the input stream to its end and cause the stream to close.","optional":false,"type":[[["Readable"]]]},{"name":"type","description":"The recommended stream type for this audio stream.","optional":false,"type":[[["StreamType"]]]}]},{"name":"SSRCMapEvents","description":"The events that an SSRCMap may emit.","meta":{"line":28,"file":"SSRCMap.ts","path":"src/receive"},"props":[{"name":"create","optional":false,"type":[[["("],["newData",": "],["VoiceUserData",") => "],["Awaited","<"],["void",">"]]]},{"name":"delete","optional":false,"type":[[["("],["deletedData",": "],["VoiceUserData",") => "],["Awaited","<"],["void",">"]]]},{"name":"update","optional":false,"type":[[["("],["oldData",": "],["undefined"," | "],["VoiceUserData",", "],["newData",": "],["VoiceUserData",") => "],["Awaited","<"],["void",">"]]]}]},{"name":"SpeakingMapEvents","description":"The events that a SpeakingMap can emit.","meta":{"line":7,"file":"SpeakingMap.ts","path":"src/receive"},"props":[{"name":"end","description":"Emitted when a user stops speaking.","optional":false,"type":[[["("],["userId",": "],["string",") => "],["Awaited","<"],["void",">"]]]},{"name":"start","description":"Emitted when a user starts speaking.","optional":false,"type":[[["("],["userId",": "],["string",") => "],["Awaited","<"],["void",">"]]]}]},{"name":"VoiceConnectionConnectingState","description":"The state that a VoiceConnection will be in when it is establishing a connection to a Discord\nvoice server.","meta":{"line":127,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"networking","optional":false,"type":[[["Networking"]]]},{"name":"status","optional":false,"type":[[["Connecting"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionDestroyedState","description":"The state that a VoiceConnection will be in when it has been permanently been destroyed by the\nuser and untracked by the library. It cannot be reconnected, instead, a new VoiceConnection\nneeds to be established.","meta":{"line":150,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"status","optional":false,"type":[[["Destroyed"]]]}]},{"name":"VoiceConnectionDisconnectedBaseState","description":"The state that a VoiceConnection will be in when it is not connected to a Discord voice server nor is\nit attempting to connect. You can manually attempt to reconnect using VoiceConnection#reconnect.","meta":{"line":88,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"status","optional":false,"type":[[["Disconnected"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionDisconnectedOtherState","description":"The state that a VoiceConnection will be in when it is not connected to a Discord voice server nor is\nit attempting to connect. You can manually attempt to reconnect using VoiceConnection#reconnect.","meta":{"line":98,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"reason","optional":false,"type":[[["AdapterUnavailable"," | "],["EndpointRemoved"," | "],["Manual"]]]},{"name":"status","optional":false,"type":[[["Disconnected"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionDisconnectedWebSocketState","description":"The state that a VoiceConnection will be in when its WebSocket connection was closed.\nYou can manually attempt to reconnect using VoiceConnection#reconnect.","meta":{"line":106,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"closeCode","description":"The close code of the WebSocket connection to the Discord voice server.","optional":false,"type":[[["number"]]]},{"name":"reason","optional":false,"type":[[["WebSocketClose"]]]},{"name":"status","optional":false,"type":[[["Disconnected"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionReadyState","description":"The state that a VoiceConnection will be in when it has an active connection to a Discord\nvoice server.","meta":{"line":138,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"networking","optional":false,"type":[[["Networking"]]]},{"name":"status","optional":false,"type":[[["Ready"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceConnectionSignallingState","description":"The state that a VoiceConnection will be in when it is waiting to receive a VOICE_SERVER_UPDATE and\nVOICE_STATE_UPDATE packet from Discord, provided by the adapter.","meta":{"line":53,"file":"VoiceConnection.ts","path":"src"},"props":[{"name":"adapter","optional":false,"type":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"status","optional":false,"type":[[["Signalling"]]]},{"name":"subscription","optional":true,"type":[[["PlayerSubscription"]]]}]},{"name":"VoiceUserData","description":"The known data for a user in a Discord voice connection.","meta":{"line":7,"file":"SSRCMap.ts","path":"src/receive"},"props":[{"name":"audioSSRC","description":"The SSRC of the user's audio stream.","optional":false,"type":[[["number"]]]},{"name":"userId","description":"The Discord user id of the user.","optional":false,"type":[[["string"]]]},{"name":"videoSSRC","description":"The SSRC of the user's video stream (if one exists)\nCannot be 0. If undefined, the user has no video stream.","optional":true,"type":[[["number"]]]}]},{"name":"AudioPlayerEvents","type":[[["{"],["\n\n","} & "],["unknown"]]],"meta":{"line":153,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"AudioPlayerState","description":"The various states that the player can be in.","type":[[["AudioPlayerIdleState"," | "],["AudioPlayerBufferingState"," | "],["AudioPlayerPlayingState"," | "],["AudioPlayerPausedState"]]],"meta":{"line":147,"file":"AudioPlayer.ts","path":"src/audio"}},{"name":"DiscordGatewayAdapterCreator","description":"A function used to build adapters. It accepts a methods parameter that contains functions that\ncan be called by the implementer when new data is received on its gateway connection. In return,\nthe implementer will return some methods that the library can call - e.g. to send messages on\nthe gateway, or to signal that the adapter can be removed.","type":[[["("],["methods",": "],["DiscordGatewayAdapterLibraryMethods",") => "],["DiscordGatewayAdapterImplementerMethods"]]],"meta":{"line":51,"file":"adapter.ts","path":"src/util"},"params":[{"name":"methods","optional":false,"type":[[["DiscordGatewayAdapterLibraryMethods"]]]}],"returns":[[["DiscordGatewayAdapterImplementerMethods"]]]},{"name":"EndBehavior","type":[[["{"],["\nbehavior",": "],["EndBehaviorType","."],["Manual\n","} | {"],["\nbehavior",": "],["EndBehaviorType","."],["AfterSilence"," | "],["EndBehaviorType","."],["AfterInactivity",","],["\nduration",": "],["number\n","}"]]],"meta":{"line":24,"file":"AudioReceiveStream.ts","path":"src/receive"}},{"name":"VoiceConnectionDisconnectedState","description":"The states that a VoiceConnection can be in when it is not connected to a Discord voice server nor is\nit attempting to connect. You can manually attempt to connect using VoiceConnection#reconnect.","type":[[["VoiceConnectionDisconnectedOtherState"," | "],["VoiceConnectionDisconnectedWebSocketState"]]],"meta":{"line":119,"file":"VoiceConnection.ts","path":"src"}},{"name":"VoiceConnectionEvents","type":[[["{"],["\n\n","} & "],["unknown"]]],"meta":{"line":164,"file":"VoiceConnection.ts","path":"src"}},{"name":"VoiceConnectionState","description":"The various states that a voice connection can be in.","type":[[["VoiceConnectionSignallingState"," | "],["VoiceConnectionDisconnectedState"," | "],["VoiceConnectionConnectingState"," | "],["VoiceConnectionReadyState"," | "],["VoiceConnectionDestroyedState"]]],"meta":{"line":157,"file":"VoiceConnection.ts","path":"src"}}]}